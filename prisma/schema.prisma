generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String           @id @default(cuid())
  email                String           @unique
  name                 String?
  passwordHash         String
  role                 String           @default("TENANT")
  emailVerified        DateTime?
  image                String?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  landlordAppointments Appointment[]    @relation("LandlordAppointments")
  tenantAppointments   Appointment[]    @relation("TenantAppointments")
  landlordProfile      LandlordProfile?
  messages             Message[]
  payments             Payment[]
  tenantProfile        TenantProfile?

  @@map("users")
}

model TenantProfile {
  id                 String          @id @default(cuid())
  userId             String          @unique
  phone              String?
  budgetMax          Float?
  monthlyIncomeRange String?
  incomeConsent      Boolean         @default(false)
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  applications       Application[]
  dossier            TenantDossier?
  user               User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  visitRequests      VisitRequest[]
  messageThreads     MessageThread[]

  @@map("tenant_profiles")
}

model LandlordProfile {
  id        String    @id @default(cuid())
  userId    String    @unique
  phone     String?
  company   String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  listings  Listing[]

  @@map("landlord_profiles")
}

model Listing {
  id                  String             @id @default(cuid())
  title               String
  description         String
  price               Float
  city                String
  area                String?
  address             String?
  postalCode          String?
  bedrooms            Int
  bathrooms           Int
  furnished           Boolean            @default(false)
  petAllowed          Boolean            @default(false)
  minTerm             Int                @default(12)
  maxTerm             Int?
  deposit             Float              @default(0)
  wifiIncluded        Boolean            @default(false)
  heatingIncluded     Boolean            @default(false)
  hotWaterIncluded    Boolean            @default(false)
  electricityIncluded Boolean            @default(false)
  images              String?
  model3dUrl          String?
  panoramaUrl         String?
  matterportUrl       String?
  sketchfabUrl        String?
  latitude            Float?
  longitude           Float?
  status              String             @default("active")
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  landlordId          String
  applications        Application[]
  appointments        Appointment[]
  availabilitySlots   AvailabilitySlot[]
  landlord            LandlordProfile    @relation(fields: [landlordId], references: [id], onDelete: Cascade)
  visitRequests       VisitRequest[]
  messageThreads      MessageThread[]

  @@map("listings")
}

model TenantDossier {
  id        String            @id @default(cuid())
  tenantId  String            @unique
  status    String            @default("incomplete")
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  documents DossierDocument[]
  tenant    TenantProfile     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("tenant_dossiers")
}

model DossierDocument {
  id         String        @id @default(cuid())
  dossierId  String
  type       String
  fileName   String
  fileUrl    String
  uploadedAt DateTime      @default(now())
  dossier    TenantDossier @relation(fields: [dossierId], references: [id], onDelete: Cascade)

  @@map("dossier_documents")
}

enum ApplicationStatus {
  DRAFT
  SUBMITTED
  ACCEPTED
  REJECTED
}

enum ConsentType {
  CREDIT_CHECK
  REFERENCES_CONTACT
  DATA_SHARING
}

model Application {
  id            String              @id @default(cuid())
  listingId     String
  tenantId      String
  landlordId    String
  appointmentId String              @unique
  status        ApplicationStatus   @default(DRAFT)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  listing       Listing             @relation(fields: [listingId], references: [id], onDelete: Cascade)
  tenant        TenantProfile       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointment   Appointment         @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  steps         ApplicationStep[]
  answers       ApplicationAnswer[]
  consents      Consent[]
  lease         Lease?
  messageThread MessageThread?

  @@map("applications")
}

model MessageThread {
  id            String         @id @default(cuid())
  applicationId String?        @unique
  listingId     String?
  tenantId      String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  application   Application?   @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  listing       Listing?       @relation(fields: [listingId], references: [id], onDelete: Cascade)
  tenant        TenantProfile? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  messages      Message[]

  @@index([listingId, tenantId])
  @@map("message_threads")
}

model Message {
  id        String        @id @default(cuid())
  threadId  String
  senderId  String
  content   String
  read      Boolean       @default(false)
  createdAt DateTime      @default(now())
  sender    User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  thread    MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@map("messages")
}

enum LeaseStatus {
  DRAFT
  TENANT_SIGNED
  OWNER_SIGNED
  FINALIZED
}

enum AnnexDocumentType {
  PAYMENT_CONSENT
  CREDIT_CHECK_AUTH
  ELECTRONIC_COMMS
}

model Lease {
  id                   String               @id @default(cuid())
  applicationId        String               @unique
  startDate            DateTime
  endDate              DateTime
  monthlyRent          Float
  deposit              Float
  terms                String
  landlordInfo         Json?                // Informations du propriétaire (section 1 TAL) pré-remplies lors de l'acceptation
  propertyInfo         Json?                 // Informations du logement (section 3 TAL) pré-remplies lors de l'acceptation
  leaseTerms           Json?                 // Conditions du bail (section 4 TAL) pré-remplies lors de l'acceptation
  additionalConditions String?               // Conditions particulières (section 5 TAL) pré-remplies lors de l'acceptation
  status               LeaseStatus          @default(DRAFT)
  documentId           String?              @unique // Unique document identifier for final PDF
  documentHash         String? // SHA-256 hash of final PDF content
  finalizedAt          DateTime?
  pdfUrl               String? // URL to final immutable PDF
  pdfVersion           Int                  @default(1) // Version number for immutable PDFs
  signedAt             DateTime? // Deprecated - use tenantSignature/ownerSignature instead
  signedBy             String? // Deprecated
  documentUrl          String? // Deprecated - use pdfUrl instead
  stripeSubscriptionId String? // ID de l'abonnement Stripe pour paiements récurrents
  paymentMethodId      String? // ID de la méthode de paiement Stripe (carte)
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  application          Application          @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  payments             Payment[]
  tenantSignature      LeaseSignature?      @relation("TenantLeaseSignature")
  ownerSignature       LeaseOwnerSignature? @relation("OwnerLeaseSignature")
  annexDocuments       AnnexDocument[]
  auditLogs            AuditLog[]

  @@map("leases")
}

model LeaseSignature {
  id              String   @id @default(cuid())
  leaseId         String   @unique
  signerId        String // User ID who signed
  signerEmail     String
  signerName      String?
  signerRole      String // "TENANT" or "LANDLORD"
  initials        String? // Tenant/owner initials
  consentGiven    Boolean  @default(false) // Checkbox confirmation
  signedAt        DateTime @default(now())
  ipAddress       String?
  userAgent       String?
  documentVersion Int      @default(1) // Document version at time of signing
  documentHash    String? // Hash of document content at signing time
  lease           Lease    @relation("TenantLeaseSignature", fields: [leaseId], references: [id], onDelete: Cascade)

  @@map("lease_signatures")
}

model LeaseOwnerSignature {
  id              String   @id @default(cuid())
  leaseId         String   @unique
  signerId        String
  signerEmail     String
  signerName      String?
  signerRole      String   @default("LANDLORD")
  initials        String?
  consentGiven    Boolean  @default(false)
  signedAt        DateTime @default(now())
  ipAddress       String?
  userAgent       String?
  documentVersion Int      @default(1)
  documentHash    String?
  lease           Lease    @relation("OwnerLeaseSignature", fields: [leaseId], references: [id], onDelete: Cascade)

  @@map("lease_owner_signatures")
}

model AnnexDocument {
  id         String            @id @default(cuid())
  leaseId    String
  type       AnnexDocumentType
  title      String
  content    String // Document content/text
  version    Int               @default(1)
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  lease      Lease             @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  signatures AnnexSignature[]

  @@unique([leaseId, type]) // One annex per type per lease
  @@map("annex_documents")
}

model AnnexSignature {
  id              String        @id @default(cuid())
  annexId         String
  signerId        String
  signerEmail     String
  signerName      String?
  signerRole      String // "TENANT" or "LANDLORD"
  consentGiven    Boolean       @default(false)
  signedAt        DateTime      @default(now())
  ipAddress       String?
  userAgent       String?
  documentVersion Int           @default(1)
  documentHash    String?
  annex           AnnexDocument @relation(fields: [annexId], references: [id], onDelete: Cascade)

  @@map("annex_signatures")
}

model AuditLog {
  id        String   @id @default(cuid())
  leaseId   String?
  annexId   String?
  userId    String?
  action    String // e.g., "LEASE_TENANT_SIGNED", "LEASE_OWNER_SIGNED", "LEASE_FINALIZED", "PDF_GENERATED", "PDF_DOWNLOADED", "ANNEX_SIGNED"
  entity    String // "LEASE" or "ANNEX"
  entityId  String? // ID of the entity
  metadata  Json? // Additional context (IP, user agent, document version, etc.)
  createdAt DateTime @default(now())
  lease     Lease?   @relation(fields: [leaseId], references: [id], onDelete: Cascade)

  @@index([leaseId])
  @@index([userId])
  @@index([action])
  @@map("audit_logs")
}

model Payment {
  id              String    @id @default(cuid())
  leaseId         String
  userId          String
  amount          Float
  type            String // "rent", "deposit", "fee"
  status          String    @default("pending") // "pending", "paid", "failed", "refunded"
  stripeId        String? // ID du paiement Stripe
  stripeInvoiceId String? // ID de la facture Stripe
  dueDate         DateTime? // Date d'échéance du paiement
  paidAt          DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  lease           Lease     @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payments")
}

model VisitRequest {
  id            String        @id @default(cuid())
  listingId     String
  tenantId      String
  status        String        @default("pending")
  message       String?
  preferredDate DateTime?
  preferredTime String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  listing       Listing       @relation(fields: [listingId], references: [id], onDelete: Cascade)
  tenant        TenantProfile @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("visit_requests")
}

model AvailabilitySlot {
  id          String       @id @default(cuid())
  listingId   String
  startAt     DateTime
  endAt       DateTime
  isBooked    Boolean      @default(false)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  appointment Appointment?
  listing     Listing      @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@map("availability_slots")
}

model Appointment {
  id          String           @id @default(cuid())
  listingId   String
  slotId      String           @unique
  tenantId    String
  landlordId  String
  status      String           @default("REQUESTED")
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  landlord    User             @relation("LandlordAppointments", fields: [landlordId], references: [id], onDelete: Cascade)
  listing     Listing          @relation(fields: [listingId], references: [id], onDelete: Cascade)
  slot        AvailabilitySlot @relation(fields: [slotId], references: [id], onDelete: Cascade)
  tenant      User             @relation("TenantAppointments", fields: [tenantId], references: [id], onDelete: Cascade)
  application Application?

  @@map("appointments")
}

model ApplicationStep {
  id            String      @id @default(cuid())
  applicationId String
  stepKey       String
  isComplete    Boolean     @default(false)
  updatedAt     DateTime    @updatedAt
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@unique([applicationId, stepKey])
  @@map("application_steps")
}

model ApplicationAnswer {
  id            String      @id @default(cuid())
  applicationId String
  stepKey       String
  version       Int         @default(1)
  data          Json
  updatedAt     DateTime    @updatedAt
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@unique([applicationId, stepKey])
  @@map("application_answers")
}

model Consent {
  id            String      @id @default(cuid())
  applicationId String
  type          ConsentType
  textVersion   String
  acceptedAt    DateTime    @default(now())
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@unique([applicationId, type])
  @@map("consents")
}

model ActivityLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String
  entity    String
  entityId  String?
  metadata  String?
  createdAt DateTime @default(now())

  @@map("activity_logs")
}
